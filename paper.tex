\documentclass{acm_sen_article}


\usepackage{color}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
%\renewcommand{\baselinestretch}{0.93}

\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Bounded Model Checking for Embedded Systems \\ (Position Paper)}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{Lucas C. Cordeiro \\
Electronic and Information Research Center\\
Federal University of Amazonas, Brazil\\
Email: lucascordeiro@ufam.edu.br
\and
Eddie B. de Lima Filho \\
Center of Science, Technology, and Innovation \\ for the Industrial Pole of Manaus, Brazil \\
Email: eddie@ctpim.org.br}
%\IEEEauthorblockN{Homer Simpson}
%\IEEEauthorblockA{Twentieth Century Fox\\
%Springfield, USA\\
%Email: homer@thesimpsons.com}
%\and
%\IEEEauthorblockN{James Kirk\\ and Montgomery Scott}
%\IEEEauthorblockA{Starfleet Academy\\
%San Francisco, California 96678--2391\\
%Telephone: (800) 555--1212\\
%Fax: (888) 555--1212}}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}



% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
Our dependency on the correct functioning of embedded systems is rapidly growing, mainly due to their wide range of applications, such as micro-grids, airbag control, health care, surveillance, mobile devices, and high-end television sets. Their structures are becoming more and more complex and now require multi-core processors with scalable shared memory, in order to meet increasing computational power demands. As a consequence, reliability of embedded (distributed) software becomes a key issue during system development, which must be carefully addressed and assured. Normally, state-of-the-art verification methodologies for embedded systems generate test vectors (with constraints) and use assertion-based verification and high-level processor model during simulation; however, other additional challenges have been raised: the need for meeting time and energy constraints, handling concurrent software, dealing with platform restrictions, evaluating implementation-structure choices, and supporting legacy designs (usually written in low-level languages). The present paper discuss challenges, problems, and recent advances to ensure correctness and timeliness regarding embedded systems. Reliability issues, in the development of micro-grids and cyber-physical systems, are then considered, as a prominent model checking application.
\end{abstract}

%\IEEEpeerreviewmaketitle


%--------------------------------------
\section{Introduction}
%--------------------------------------

Generally, embedded computer systems perform dedicated functions with high degree of reliability. They are used in a variety of sophisticated applications, which range from entertainment software, such as games and graphics animation, to safety-critical systems, such as nuclear reactors and automotive controllers~\cite{Kopetz11}. Embedded systems are ubiquitous, in modern day information systems, and are also becoming increasingly important in our society, especially in micro-grids, where reliability and carbon emission reduction are of paramount importance, and in cyber-physical systems, which demand short development cycles and high-level of reliability~\cite{leeCPS}. As a consequence, human life has also become more and more dependent on the services provided by this type of system; in particular, their success depends both on the provided service relevance and quality. 

Indeed, many current embedded systems become interesting solutions only if they can reliably
performs their target tasks, such as unmanned aerial vehicles (UAVs) and medical monitoring systems. For instance, UAVs are a trend on military missions, due to the absence of pilots; however, an incorrect plan execution may also cost human-lives, which is unacceptable. In addition, wrong diagnosis or condition-evaluation reports also have the potential to compromise patients' health, with serious consequences.

A number of distinctive characteristics might influence the embedded system development and verification process, which include: mass production and static structure, functionality determined by software in read-only memory, multi-core processors with scalable shared memory, and limited amount of energy. Additionally, the increasing computational power and decreasing size and cost common to computer processors is enabling system designers to move more features to software, which consequently leads to difficulties in verifying design correctness, since stringent constraints imposed by the underlying hardware ({\it e.g.}, real-time, memory allocation, interrupts, and concurrency) must be considered during verification~\cite{Kroening15}.

%--------------------------------------
\section{Verification Challenges}
%--------------------------------------

State-of-the-art verification methodologies for embedded systems generate test vectors (with constraints), use assertion-based verification, and high-level processor models during simulation~\cite{Behrend15,Lettnin09}; however, embedded system verification also raises additional challenges, such as time and energy constraints, handling of concurrent software, platform restrictions, and legacy designs, which are usually developed in low-level languages. In summary, the main challenges regarding the verification of embedded systems lie on improving coverage, where more system's functions are verified, reducing verification time, {\it i.e.}, pruning the state-space exploration during verification, and incorporating system models, which allows specific checks regarding system behavior and not only code correctness. For instance, such aspects are of extreme relevance in micro-grids and cyber-physical systems, in order to ensure reliability, which is a key issue for (smart) cities, industries, and consumers.
%In summary, the main challenge when verifying embedded systems lies on improving coverage, where more system's functions are verified, and reducing verification time, {\it i.e.}, pruning the state-space exploration during verification. These aspects are of extreme relevance in micro-grids to ensure reliability, which is a key issue for (smart) cities and consumers.

%--------------------------------------
\section{Research Problem (RP)}
%--------------------------------------

This position paper tackles four major problems in computer-aided verification for embedded systems: (RP1) providing suitable encodings into the Satisfiability Modulo Theories (SMT) \cite{BarrettSST09}, in particular, extend background theories typically supported by SMT solvers to reason accurately and effectively about realistic embedded programs, (RP2) exploiting SMT techniques to leverage bounded model checking of multi-threaded software, in order to mitigate the state-explosion problem due to threads interleavings, (RP3) proving correctness and timeliness of embedded systems, by taking into account stringent constraints imposed by hardware, and (RP4) incorporating knowledge about system purpose and associated features, in order to detect system-level failures.

%--------------------------------------
\section{Bounded Model Checking of Embedded Systems}
%--------------------------------------

Bounded Model Checking (BMC) techniques based on Boolean Satisfiability (SAT)~\cite{handbook09} or SMT~\cite{BarrettSST09} have been successfully applied to verify single- and multi-threaded programs and find subtle bugs in real (embedded systems) software~\cite{Clarke04,MerzFS12,CordeiroF11,Ivancic05,Cordeiro12}. The idea behind the BMC techniques is to check the violation of a given property at a predetermined depth, {\it i.e.}, given a transition system \textit{M}, a property $ \phi $, and a limit of iterations \textit{k}, BMC unfolds the system \textit{k} times and converts it into a Verification Condition (VC) $ \psi $, such that $\psi$ is \textit{satisfiable} if and only if $\phi$ has a counterexample of depth
less than or equal to \textit{k}.

In order to reason about embedded software accurately, an SMT-based BMC must consider a number of issues that are not easily mapped into the (background) theories supported by SMT solvers, {\it e.g.}, real-time, memory allocation, interrupts, and concurrency. Moreover, BMC techniques are able to falsify properties up to a depth \textit{k}. Consequently, they are able to prove system correctness only if an upper bound \textit{k} is known, {\it i.e.}, a bound that unfolds all loops and recursive functions to their maximum possible depth. In particular, BMC techniques limit the addressed regions of data structures ({\it e.g.}, arrays) and the number of loop iterations to a given bound $k$, which then restricts the state space that must be explored during verification, in such a way that real errors in applications \cite{Clarke04,MerzFS12,Ivancic05,Cordeiro12} can be found. Nonetheless, BMC tools are susceptible to exhaustion of time or memory limits, when checking programs with loops whose bounds are too large or cannot be statically determined.  

%--------------------------------------
\subsection{Induction-based Verification of C Programs}
%--------------------------------------

A feasible alternative to check properties in BMC is to prove that an invariant (assertion) is \textit{k}-inductive~\cite{EenS03,Sheera00}. 
The simplest form of \textit{k}-induction consists of two steps: the \textit{base-case} and the \textit{induction-step}. In the base-case, we aim to check that $\phi$ holds in all states reachable from an initial state within $k$ steps (we assume that $k \geq 0$) and in the induction-step, we aim to check that whenever $\phi$ holds in $k$ consecutive states $s_1,\ldots,s_k$, $\phi$ also holds in the next state $s_{k+1}$ of the system. In particular, the \textit{k}-induction algorithm was successfully applied to ensure that (restricted) C programs do not contain data races~\cite{Donaldson10,Kinductor} and do respect time constraints specified during the system design phase~\cite{EenS03}. Additionally, the \textit{k}-induction is a well-established technique in hardware verification, where it is easier to be applied, due to the monolithic transition relation present in such designs~\cite{EenS03,GrosseLD09,Sheera00}. Recently, Gadelha {\it et al.} and Beyer {\it et al.} presented a new algorithm for proving correctness of (a large set of) C programs by mathematical induction, in a completely automatic way ({\it i.e.}, users do not need to provide the loop invariant)~\cite{Gadelha15,Beyer15}. However, there is still little evidence in the associated literature that model checking embedded software, using \textit{k}-induction (and invariants), can be efficiently exploited in embedded system verification~\cite{Rocha15,Brain15}.

%--------------------------------------
\subsection{Incorporating System Knowledge to Verification}
%--------------------------------------

It is worth noticing that, currently, SMT-based BMC approaches check for code properties in real programs, which basically address programing language issues and general correctness, without taking into account target applications or system behavior. Such a statement is important, since, as already mentioned, many system features are being moved to software domain, which then claims for schemes that not only check if source code is correctly written, but also if it will respond properly in real environments or under external problems. For instance, the anti-lock braking system software of a car model can be bug free, but it may not work properly if a sensor is damaged.

Indeed, research in software verification is now taking such considerations into account and some schemes already use knowledge about the system to be verified and the underlying hardware. Recently, Husamma {\it et al.} proposed a verification tool for digital systems to aid enginners to check for overflow, limit cycle, error, timing, stability, and minimum phase in digital systems, considering finite word length (FWL) effects~\cite{dsv_spin2015}.

%--------------------------------------
\section{Achievements}
\label{achievements}
%--------------------------------------

\textbf{(RP1)} Cordeiro {\it et al.} proposed the first SMT-based BMC for full C programs (ESBMC)~\cite{Cordeiro12}, which was later extended to C++98 programs~\cite{ECBS13}. \textbf{(RP2)} This SMT-based BMC approach was further developed to verify deadlock, data races, and atomicity violations in multi-threaded software based on POSIX and CUDA libraries~\cite{CordeiroF11,Pereira15}, considering partial-order reduction and state-hashing techniques to prune the state-space exploration~\cite{morse15}. These verification methodologies and respective tools were also able to find undiscovered bugs related to arithmetic overflow, buffer overflow, and invalid pointer in standard benchmarks, which were confirmed by the benchmark's creators ({\it e.g.}, NOKIA, NEC, NXP, and VERISEC). \textbf{(RP3)} Novel approaches to model check embedded software using \textit{k}-induction and invariants were proposed and evaluated, demonstrating is effectiveness in some real-life embedded systems applications~\cite{Gadelha15,Rocha15}. \textbf{(RP4)} The proposed SMT-based context-BMC was also extended to verify overflow, limit cycle, time constraints, stability, and minimum phase in discrete-time systems, in particular, digital filters and controllers~\cite{dsv_spin2015,esbmc_controller,esbmc_filter} and to specify system-level properties using linear-time temporal logic~\cite{JMorse15}. Lastly, yet importantly, ESBMC represents one of the most prominent BMC tools (for verifying embedded systems) as observed in the international software verification competitions~\cite{MorseCNF13,MorseRCN014}.

%--------------------------------------
\section{Conclusions}
\label{conclusions}
%--------------------------------------

This paper presented the main challenges to verify design correctness in embedded systems. In particular, it emphasizes that stringent constraints imposed by the hardware ({\it e.g.}, real-time, memory allocation, interrupts, and concurrency) must be considered during verification. Additionally, there is little evidence that model checking embedded software using \textit{k}-induction (and invariants), which
extends BMC-based approaches from falsification to verification, can be applied to formally verify the correctness and the timeliness of embedded systems. Given that the complexity of software has increased significantly in embedded products, there are still some (recent) advances to stress and cover exhaustively the state space of the system, in order to verify low-level properties that have to meet the application's deadline, access the memory region, handle concurrency, and control the hardware registers. As future work, the main goal of this research is to extend BMC as a design and verification tool for achieving a correct-by-construction embedded systems implementation; special attention will be given to cyber-physical systems and modern micro-grids, considering small-scale versions of a distributed system so that reliability and other system-level properties ({\it e.g.}, carbon emission reduction in smart cities) are amenable to automated verification.



% conference papers do not normally have an appendix


% use section* for acknowledgment
\section*{Acknowledgment}

%The authors would like to thank...
This research was supported by CNPq $475647$/$2013$-$0$ grant.



\begin{thebibliography}{1}

\bibitem{Kopetz11}
H.~Kopetz.
\newblock {\em Real-Time Systems - Design Principles for Distributed Embedded Applications}.
\newblock Real-Time Systems Series, Springer, ISBN 978-1-4419-8236-0, pp. 1--376, 2011.

\bibitem{leeCPS}
E.~Lee 
\newblock {\em Cyber-physical Systems: Design Challenges.} 
\newblock In: International Symposium on Object Oriented Real-Time Distributed Computing, pp. 363--369, 2008.

\bibitem{Kroening15}
Kroening D., Liang L., Melham T., Schrammel P., Tautschnig M.:
\newblock {\em Effective Verification of Low-Level Software with Nested Interrupts}. 
\newblock In: Design, Automation and Test in Europe, pp. 229--234, 2015.

\bibitem{Behrend15}
Behrend J., Lettnin D., Gruenhage A., Ruf J., Kropf T., Rosenstiel W.:
\newblock {\em Scalable and Optimized Hybrid Verification of Embedded Software}. 
\newblock In: J. Electronic Testing 31(2): pp. 151--166, 2015.

\bibitem{Lettnin09}
Lettnin D., Nalla P. K., Behrend J., Ruf J., Gerlach J., Kropf T., Rosenstiel W., Schönknecht V., Reitemeyer S.:
\newblock {\em Semiformal Verification of Temporal Properties in Automotive Hardware Dependent Software}. 
\newblock In: Design, Automation and Test in Europe, pp. 1214--1217, 2009.

\bibitem{handbook09}
Biere A., Heule M., van Maaren H., Walsh T., eds.:
\newblock {\em Handbook of Satisfiability}.
\newblock Volume 185 of Frontiers in Artificial Intelligence and Applications., {IOS} Press, 2009.

\bibitem{BarrettSST09}
Barrett C., Sebastiani R., Seshia S.A., Tinelli C.:
\newblock {\em Satisfiability Modulo Theories}. 
\newblock In: Volume 185 of Frontiers in Artificial Intelligence and Applications. IOS Press, pp. 825--885, 2009.

\bibitem{Clarke04}
Clarke E., Kroening D., Lerda F.:
\newblock {\em A Tool for Checking {ANSI-C} Programs.}
\newblock In: Tools and Algorithms for the Construction and Analysis of Systems. LNCS 2988, Springer Berlin Heidelberg,  pp. 168--176, 2004.

\bibitem{MerzFS12}
Merz F., Falke S., Sinz C.:
\newblock {\em {LLBMC}: Bounded Model Checking of {C} and {C++} Programs using a Compiler {IR}.}
\newblock In: International Conference on Verified Software: Theories, Tools, Experiments. LNCS 7152, pp. 146--161, 2012.

\bibitem{CordeiroF11}
Cordeiro L., Fischer B.:
\newblock {\em Verifying Multi-threaded Software using {SMT}-based Context-Bounded Model Checking.}
\newblock In: International Conference on Software Engineering. ACM,  pp. 331--340, 2011.

\bibitem{Ivancic05}
Ivanicic F., Shlyakhter I., Gupta A., Ganai, M.K.:
\newblock {\em Model Checking {C} Programs using {F-Soft}.}
\newblock In: IEEE International Conference on Computer Design: VLSI in Computers and Processors, pp. 297--308, 2005.

\bibitem{Cordeiro12}
Cordeiro L., Fischer B., Marques{-}Silva J.:
\newblock {\em {SMT}-based Bounded Model Checking for Embedded {ANSI-C} Software.}
\newblock {IEEE} Trans. Software Eng. \textbf{38}(4), pp. 957--974, 2012.

\bibitem{Donaldson10}
Donaldson A., Kroening D., R{\"{u}}mmer P.:
\newblock {\em {SCRATCH}: A Tool for Automatic Analysis of {DMA} Races.}
\newblock In: ACM Symposium on Principles and Practice of Parallel Programming. ACM, pp. 311--312, 2011.

\bibitem{Kinductor}
Donaldson A., Haller L., Kroening D., R{\"{u}}mmer, P.:
\newblock {\em Software Verification using \textit{k}-Induction.}
\newblock In: International Conference on Static Analysis. LNCS 6887, pp. 351--368, 2011.

\bibitem{EenS03}
E{\'{e}}n, N., S{\"{o}}rensson, N.:
\newblock {\em Temporal Induction by Incremental {SAT} Solving.}
\newblock Electronic Notes in Theoretical Computer Science \textbf{89}(4), pp. 543 -- 560, 2003.

\bibitem{GrosseLD09}
Gro{\ss}e D., Le H., Drechsler R.:
\newblock {\em Induction-based Formal Verification of {SystemC TLM} Designs.}
\newblock In: International Workshop on Microprocessor Test and Verification, pp. 101--106, 2009.

\bibitem{Sheera00}
Sheeran M., Singh S., St{\aa}lmarck G.:
\newblock {\em Checking Safety Properties using Induction and a {SAT}-solver.}
\newblock In: International Conference on Formal Methods in Computer-Aided Design. Springer-Verlag, pp. 108--125, 2000.

\bibitem{Gadelha15}
Gadelha M., Ismail H., Cordeiro L.:
\newblock {\em Handling Loops in Bounded Model Checking of C Programs via \textit{k}-Induction.}
\newblock In: International Journal on Software Tools for Technology Transfer (to appear), pp. 1--18, 2015.
\newblock http://dx.doi.org/10.1007/s10009-015-0407-9

\bibitem{Beyer15}
Beyer D., Dangl M., Wendler P.:
\newblock {\em Boosting \textit{k}-Induction with Continuously-Refined Invariants.}
\newblock International Conference on Computer-Aided Verification, LNCS 9206, pp. 622--640, 2015.

\bibitem{Rocha15}
Rocha H., Ismail H., Cordeiro L., Barreto R.:
\newblock {\em Model Checking Embedded C Software using k-Induction and Invariants.}
\newblock V Brazilian Symposium on Computing Systems Engineering (to appear), pp. 1--6, 2015.

\bibitem{Brain15}
Brain M., Joshi S., Kroening D., Schrammel P.:
\newblock {\em Safety Verification and Refutation by k-Invariants and k-Induction.}
\newblock In: International Symposium on Static Analysis, LNCS 9291, pp. 145--161, 2015.

\bibitem{dsv_spin2015}
Ismail H., Bessa I., Cordeiro L., Lima Filho E., Chaves Filho J.:
\newblock {\em DSVerifier: A Bounded Model Checking Tool for Digital Systems}. 
\newblock In: International SPIN Symposium on Model Checking of Software, LNCS 9232, pp. 126--131, 2015.

\bibitem{ECBS13}
Ramalho M., Lopes M., Sousa F., Marques H., Cordeiro L., Fischer B.:
\newblock {\em {SMT-Based Bounded Model Checking of C++ Programs} }.
\newblock In: International Conference on Engineering of Computer-Based Systems, pp. 147--156, 2013.

\bibitem{Pereira15}
Pereira P.  Albuquerque H., Marques H., Silva I., Carvalho C., Santos V., Ferreira R., Cordeiro L.: 
\newblock {\em Verifying CUDA Programs using SMT-Based Context-Bounded Model Checking.} 
\newblock To appear in ACM Symposium on Applied Computing, Software Verification and Testing, 2016. 

\bibitem{morse15}
J.~Morse.
\newblock {\em {Expressive and Efficient Bounded Model Checking of Concurrent Software}}.
\newblock {University of Southampton, PhD Thesis}, 2015.

\bibitem{esbmc_controller}
Bessa I., Abreu R., Cordeiro L., Filho J.:
\newblock {\em {SMT-Based Bounded Model Checking of Fixed-Point Digital Controllers)}.}
\newblock In: Annual Conference of the Industrial Electronics Society, pp. 295--301, 2014.

\bibitem{esbmc_filter}
Abreu R., Cordeiro L., Filho E.:
\newblock {\em {Verifying Fixed-Point Digital Filters using SMT-Based Bounded Model Checking}.}
\newblock In: XXXI Brazilian Symposium on Telecommunications, 2013.
\newblock http://dx.doi.org/10.14209/sbrt.2013.57

\bibitem{JMorse15}
Morse J., Cordeiro L., Nicole D., Fischer B.:
\newblock {\em {Model Checking LTL Properties over ANSI-C Programs with Bounded Traces.}} 
\newblock In: Software and System Modeling 14(1): pp. 65--81, 2015.

\bibitem{MorseCNF13}
Morse J., Cordeiro L., Nicole D., Fischer B.:
\newblock {\em Handling unbounded loops with {ESBMC} 1.20.}
\newblock In: Tools and Algorithms for the Construction and Analysis of
  Systems. LNCS 7795, Springer Berlin Heidelberg, pp. 619--622, 2013.

\bibitem{MorseRCN014}
Morse J., Ramalho M., Cordeiro L., Nicole D., Fischer B.:
\newblock {\em {ESBMC} 1.22.}
\newblock In: Tools and Algorithms for the Construction and Analysis of
  Systems. LNCS 8413, Springer Berlin Heidelberg, pp. 405--407, 2014.

\end{thebibliography}




% that's all folks
\end{document}


